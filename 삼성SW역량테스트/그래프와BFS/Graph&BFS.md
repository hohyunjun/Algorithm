# Graph & BFS

 ## Graph
  - 자료구조의 일종
  - 정점(Node, Vertex)
  - 간선(Edge) : 정점간의 관계를 나타낸다.
  - G = (V,E)로 나타낸다.
  - 경로 : 정점 A에서 B로 가는 경로
   + 경로 중에서도 의미를 가지는 것은 최단경로
  - 사이클 : 정점 A에서 다시 A로 돌아오는 경로
  - 단순 경로와 단순 사이클 : 경로/사이클에서 같은 정점을 두 번이상 방문하지 않는 경로/사이클
   + 특별한 말이 없으면, 일반적으로 사용하는 경로와 사이클은 단순 경로/사이클을 말한다. 
  - 유향 그래프(Directed Graph) 와 무향 그래프(Undirected Graph)
   + 무향 그래프는 양방향 그래프(Bidirection Graph)라고도 한다. 
  - 두 정점 사이에 간선이 여러 개일 수도 있다.
  - 가중치
   + 간선에 가중치가 있는 경우에는, A에서 B로 이동하는 거리, 이동하는데 필요한 시간, 이동하는데 필요한 비용 등등등...
  - 차수
   + 정점과 연결되어 있는 간선의 개수
   + 유향 그래프의 경우에는 In-degree, Out-degree로 나누어서 차수를 계산한다.

 ## Graph의 표현
  - Graph를 저장한다 = 어떤 정점 x와 연결된 간선을 효율적으로 찾기 위한 방식으로 저장한다.
  - 인접 행렬
   + 정점의 개수를 V라고 했을 때, V*V 크기의 이차원 배열을 이용한다.
   + A[i][j] = 1 (i -> j 간선이 있을 때), 0(없을 때)
   + 가중치 그래프의 경우 1 대신 가중치 값을 넣어주면 된다. 
   + 공간 복잡도는 O(V^2)
  - 인접 리스트
   + A[i] = i와 연결된 정점을 리스트로 포함하고 있음
   + 인접 리스트를 저장할 때는 동적인 배열을 사용해야 한다. 
   + 따라서, 링크드 리스트나 길이를 동적으로 변경할 수 있는 배열을 사용한다.(C++ Vector, Java ArrayList 사용)
   + 가중치 그래프의 경우, pair 형태로 가중치도 함께 리스트 형태로 저장한다.  
   + 공간 복잡도는 O(E) : 간선의 개수만큼 공간이 필요하다. 
   + 일반적으로, E < V^2 이므로, 인접 리스트가 인접 행렬에 비해 매우 효율적이다. 
  ```
  인접 행렬이 인접 리스트보다 유리한 경우
   - 임의의 두 정점 (u, v)가 주어졌을 때, u->v 간선이 존재하는지 찾는 것이 O(1)만큼 걸린다.
   - 임의의 두 정점 (u, v)가 주어졌을 때, v->u 간선이 존재하는지 찾는 것이 O(1)만큼 걸린다. 
  x와 연결된 모든 간선을 찾는데 걸리는 시간
   - 인접 행렬 : O(v) (A[x][1] ~ A[x][v])
   - 인접 리스트 : O(차수)
   - 인접 리스트가 인접 행렬보다 훨씬 시간이 빠르다. 
  ```
  - 간선 리스트
   + 배열을 이용해서 구현한다. 
   + 간선을 모두 저장하고 있다.
   + 동적 할당 없이 인접리스트와 비슷한 효과를 낼 수 있다.
   + E라는 배열에 모든 간선을 저장한다.

 ## 그래프의 탐색
  - 목적 : 임의의 시작점 x에서 시작해서 모든 정점을 1번씩만 방문하는 것
  - DFS(깊이 우선 탐색) / BFS(너비 우선 탐색) 가 있다. 
  - DFS 
   + 스택을 사용하여 구현한다.
   + 스택에 지금까지 지나쳐온 정점들이 모두 기록되어 있다.
   + 재귀 호출을 이용한 구현
   ```c++
   // 인접 행렬을 이용한 구현 : 시간 복잡도는 O(v^2) dfs함수가 v번 호출됨
   // dfs(x)의 의미는 x 정점에 방문했다는 것. 
   void dfs(int x){
     check[x] = true;
     printf("%d ", x);
     for(int i=1; i<=n; i++){
       if(a[x][i] == 1 && check[i] == false){
         dfs(i);
       }
     }
   }
   ```
   ```c++
   // 인접 리스트를 이용한 구현 : 시간 복잡도는 O(v+e) dfs 함수가 v번 호출, for문은 간선의 개수만큼만 돌아감
   void dfs(int x){
     check[x] = true;
     printf("%d ", x);
     for(int i=0; i<a[x].size(); i++){
       int y = a[x][i];
       if(check[y] == false){
         dfs(y);
       }
     }
   }
   ```
  - BFS
   + 큐를 사용한다.
   + 꼭 큐에 넣음과 동시에 방문했다고 표시해 주어야 한다.
   + 인접 행렬 형태로 구현한 BFS 와 인접 리스트 형태로 구현한 BFS의 시간 복잡도는 O(v^2)과 O(v+e)로 DFS와 동일하다.
   
 ## 관련문제
  - DFS와 BFS(BOJ 1260)
  - 연결 요소(BOJ 11724)
  - 이분 그래프(BOJ 1707)

 ## 플러드 필
  - 어떤 위치와 연결된 모든 위치를 찾는 알고리즘 
  - 단지번호 붙이기(BOJ 2667)
  - 섬의 개수(BOJ 4963)

 ## BFS
  - **BFS의 목적은 임의의 정점에서 시작해서, 모든 정점을 한 번씩 방문하는 것이다**
  - BFS는 모든 가중치가 1일 때, 최단 거리를 구하는 알고리즘이다.
  - BFS를 이용해 해결할 수 있는 문제(최단거리 문제의 경우)는 아래와 같은 조건을 만족해야 한다.
   + 최소 비용 문제이어야 한다.
   + 간선의 가중치가 1이어야 한다.
   + 정점과 간선의 개수가 적어야 한다. (적다는 것은 문제의 조건에 맞춰서 해결할 수 있다는 것을 의미한다.)
    - 간선의 가중치가 문제에서 구하라고 하는 최소 비용과 의미가 일치해야 한다.
    - 즉, 거리의 최소값을 구하는 문제라면 가중치는 거리를 의미해야 하고, 시간의 최소값을 구하는 문제라면
      가중치는 시간을 의미해야 한다. 
  - 미로 탐색(BOJ 2178)
   + 이 문제는 DFS로는 절대로 해결 할 수 없다.
    - DFS는 시작에서 도착으로 갈수 있는지 없는지를 판단할 수 있다. 
    - 시작에서 도착으로 갈 수 있는 길 아무거나를 찾을 수는 있다.
    - 하지만, 최소 거리를 찾을 수는 없다.
    - 백트래킹을 통해 경로를 여러개 구하면? -> 한 정점을 두 번 이상 방문하게 된다. 
    - 같은 정점을 두 번 이상 방문하면 DFS가 아니라, Brute Force 알고리즘이다. 
  - 토마토(BOJ 7576)
  - 위의 두 문제는 둘 다 그래프 문제처럼 생긴 것들이다. 
  - 그래프 문제가 아닌 것 같은 것을 그래프 문제로 변형시키는 형태의 문제들을 풀어보자. 
  - 숨바꼭질(BOJ 1697)
   + 위치가 정점이고, 이동하는 것(+1, -1, *2)이 간선이다.
   + 가중치는 1 이다.(이동하는데 걸리는 시간이 1초)
  - BFS 예제
   + 같은 정점이라도 이동할 수 있는 간선이 다르면 다른 정점으로 생각해야 한다.
   + 예제에서 위 B와 아래 B를 다르다고 하는 기준은 파란 간선을 사용한 횟수이다.
   + 따라서, 정점을 파란 간선을 사용한 횟수를 기준으로 나눌 수 있다.
   + 이와 같이 문제에서 나온 정점을 그대로 해선 안 되는 경우가 있음을 알아두자. 
  - 이모티콘(BOJ 14226)
   + 어렵다..;
   + BFS에서 하나의 정점이 서로 다른 두 개의 정보를 저장하고 있으면 안된다.
   + 화면에 있는 이모티콘의 개수가 5개인 경우
   + 클립보드에 있는 이모티콘의 개수에 따라서, 클립보드에서 복사하기 연산의 결과가 다르다.
   + 즉, 화면에 이모티콘의 개수 s와 클립보드에 있는 이모티콘의 개수 c가 중요하다.
   + 복사연산 : (s,c) -> (c,c)
   + 붙여넣기 : (s,c) -> (s+c, c)
   + 삭제 : (s,c) -> (s, c-1)

 ## 덱 활용하기
  - Deque(Double Ended Queue)
   + 큐의 양 끝에서 push와 pop을 할 수 있는 자료구조
  - 숨바꼭질3(BOJ 13549)
   + 순간이동(2*x)의 소모값이 0초이다. 
   + BFS로 최단거리 문제를 풀 수 있었던 이유는 단계별로 진행되는 특성 덕분이었다. 
   + BFS는 모든 정점을 한 번씩만 방문해야 한다. 
   + 풀이 1) 큐를 두개를 활용해 풀 수 있다.
    - BFS가 진행될 때, 큐에 들어가 있는 정점들의 거리의 차이는 1을 넘을 수 없음을 이용한다.
    - 현재 큐(가중치가 0인 경우), 다음 큐(가중치가 1인경우)를 나누어서 만든다. 
    - BFS의 우선순위를 정해줄 수 있다.
    - 거리가 0인것 먼저 처리 -> 거리가 1인것 처리
   + 풀이 2) 덱을 활용할 수 있다.
    - 가중치가 0인 녀석들은 앞에, 1인 녀석들은 뒤에 넣는 방식으로 사용 가능하다.
  - 알고스팟(BOJ 1261)
   + (0,0) 에서 (n,m) 까지 가는 최단거리를 구하는데, 가중치가 0,1 인 경우
   + 데크를 사용해서 쉽게 풀 수 있다.
  - 가중치가 0, 1인 경우에는 덱을 쓰는 것이 가장 좋다.

 ## BFS2
  - 벽 부수고 이동하기(BOJ 2206)
   + 앞에서 배웠던 파란간선 예제와 똑같은 경우.
   + 벽을 이미 부순 경우와 부수지 않은 경우, 할 수 있는 선택이 다르므로 이 둘은 다른 정점이다.
   + 따라서, (x,y,c) 의 3개 정점을 가지고 BFS를 진행해야 한다.(c는 벽을 부순 횟수)
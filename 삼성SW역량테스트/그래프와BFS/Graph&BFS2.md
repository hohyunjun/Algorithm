# Graph & BFS2 (SW 역량테스트 준비 - 연습)

 ## BFS

 - BFS로 문제를 푼다는 것은 문제에 나타난 어떤 상황을 그래프로 나타낸다는 것이다.
 - 그래프의 모든 간선의 가중치가 1이 나온다는 것을 확인해야 한다.

 - 퍼즐(BOJ 1525)
 
  + 시작 퍼즐에서 도착 퍼즐까지 가는 최소연산횟수를 구한다.
  + 모든 연산의 가중치는 1이다.
  + 가능한 정점의 개수도 9!, 약 30만 개로 충분히 연산 가능하다. 
  + 따라서, BFS로 풀 수 있다.

 - 물통(BOJ 2251)
  + 처음에 풀 때는 튜플을 이용해서 풀었다.
  + 하지만, 중간에 물이 손실되지 않는 성질을 이용해서 첫 번째, 두 번째 물통에 들어있는 물의 양만 알면
    세 번째 물통에 들어있는 물의 양을 알 수 있다. 
  + 일반적인 BFS 문제인데, 처리할 것이 많았던 문제.
 - 숨바꼭질2(BOJ 12851)
  + 일반적인 BFS로 풀어봤는데, 큐에 넣어주는 것을 잘못 생각해서 처음에 틀렸다.
  + 경우의 수는 DP를 이용해서 구하면 더 쉽게 구할 수 있다.
 - 탈옥(BOJ 9376)
  + 가중치가 0과 1이 나오는 그래프 : 단계별로 BFS를 진행하거나 Deque을 이용해서 풀 수 있다. 
  + 두 죄수라는 것 때문에 까다롭다. 이전까지 풀었던 문제는 시작점 하나에서 도착점까지 가는 최단거리 형태
  + 임의의 어떤 점 (x,y)까지 밖에서부터 이동하는 거리, 죄수 1로부터 이동하는 거리, 죄수 2로부터 이동하는 거리의 BFS를 구하여 최솟값을 구할 수 있다.
  + 두 죄수의 탈옥 경로는 어딘가에서 만나서 함께 이동하는 꼴이 되기 때문이다.
  + 즉, 시작점이 3개이고 도착점이 하나인데, 각각이 다 별개의 BFS가 된다. 
  + 각각 BFS를 돌려서, 모든 벽이 아닌 정점에서의 세 개의 합을 구한다 -> 그 점이 문일 경우에는 정답에서 -2를 한다.
  + **가중치가 0과 1인 deque를 활용하는 문제**
 - 열쇠(BOJ 9328)
  + 생각하기 매우 어려웠음 ㅠ
  + door를 vector형태가 아니라 queue형태로 놓고 열쇠 발견 시, 해당 door에 대한 BFS 수행
  + door의 좌표를 큐에 넣고, 이미 방문한 문은 pop하는 형태로 방문한 곳을 또 방문하는 것을 방지할 수 있다.
 - 로봇 청소기(BOJ 4991)
  + 처음 푼 방식은 시작위치에서 가장 가까운 더러운 칸까지 이동 후, 해당 칸을 시작 위치로 바꿔서 가장 가까운 더러운 칸까지 이동하는 방식으로 구했다. 근데 틀림
  + 왜 틀렸을까?
  + 로봇청소기랑 제일 가까운 칸으로 갔다가 그 다음 칸이 제일 긴 경우가 발생할 수 있다.
  + 결국, 해설처럼 모든 칸의 방문순서를 다 고려해서 최소값을 구하는 게 맞는 것 같다.
  + 해설에서 푼 방식은, 더러운 칸을 어떤 순서로 청소하느냐에 따라 필요한 최소 이동횟수가 달라지고, 더러운 칸의 개수가 10 이하이므로
  + 더러운 칸의 방문 순서를 순열을 통해 바꾸어 모든 경우에 대한 최소 이동 횟수를 구했다.
  + 해설처럼 풀어보는 과정에서, 각 dirt 마다의 check 배열을 어떤 식으로 저장해야 할지가 막막했다.
  + 어떤 인덱스에 대해 2차원 배열을 저장하는 것을 어떻게 하지?
  + 그럴 필요가 없었다. 청소기와 각 dirt에 숫자를 붙여준 뒤에, 각 숫자에서 숫자로 이동 시의 거리를 2차원 배열 형태로 저장한다.
  + d[i][j] 뿐만 아니라 d[j][i]도 채워주어야 한다.
 - 레이저 통신(BOJ 6087)
  + 레이저가 동작하는 방식대로 BFS를 수행해 본다.
  + 인접한 정점 뿐만 아니라, 4방향의 모든 정점을 큐에 넣는다.
  + 거울의 갯수 = 두 점 사이의 직선개수 - 1
 - 0과 1(BOJ 8111) 
  + 
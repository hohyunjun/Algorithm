
 ## Dynamic Programming
  - 큰 문제를 작은 문제로 나눠서 푸는 알고리즘
  - 또 이런 알고리즘이 있는데, 분할 정복 알고리즘이 있다.
  - 분할 정복과의 차이점? : 다이나믹 프로그래밍은 작은 문제가 여러번 나오는데, 작은 문제의 정답이 항상 같다는 것을 이용하는 것.
  - 분할 정복은, 큰 문제를 작은문제로 나누어 푸는데, 작은 문제가 중복되지 않음. 모든 작은문제가 한 번씩 나옴.
  - 두 가지 속성을 만족해야 다이나믹 프로그래밍으로 문제를 풀 수 있다.
   + Overlapping Subproblem(겹치는 부분 문제)
   + Optimal Substructure(최적 부분 구조)
  - 피보나치 수 예시
   + F(n) = F(n-1) + F(n-2)
   + 작은 문제들의 Overlapping이 발생한다. 
   + 큰 문제와 작은 문제를 같은 방법으로 풀 수 있다. 
  - 최적 부분 구조 예시
   + 작은 문제의 정답이 큰 문제의 정답에서 이용된다. 
   + 최적 부분 구조를 만족한다면, 문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다.
    - n번째 피보나치 수를 구하면서 구한 4번째 피보나치수
    - n-1 번재 피보나치 수를 구하면서 구한 4번재 피보나치수
    - 4번째 피보나치 수는 항상 같다. 
  - 다이나믹 프로그래밍에서 각 문제는 한 번만 풀어야 한다.
  - Optimal Substructure를 만족하기 때문에, 같은 문제는 구할 때마다 정답이 같다.
  - 따라서, 정답을 한 번 구했으면, 정답을 어딘가에 메모해 놓는다.

 ## 다이나믹 구현
  - Top-down
   + 재귀함수 사용
  - Bottom-up
   + For문 사용
   + 문제를 크기가 작은 것부터 차례대로 푼다.
   + 문제의 크기를 조금씩 크게 만들면서 문제를 점점 푼다.
  - 둘 중 아무거나 자신있는 걸 쓰면 된다. 
  - Top-down 과 Bottom-up 중 어떤 것이 시간이 더 빠를까? : 알 수 없다.
  - Bottom-up은 모든 경우를 다 풀어야 하지만, Top-down은 경우에 따라서 일부 경우를 안 풀어도 될 수 있다. 
  - Top-down은 문제를 쪼개서 풀지 않은 것만 풀기 때문에
  - 반대로, 전체 경우의 수를 다 구해야 할 경우 Bottom-up이 더 빠를 것이라고 생각된다.
  - 실제로, Top-down과 Bottom-up의 시간 복잡도는 같다. 

 ## 문제 풀이 전략
  - 점화식을 정의한다.
   + 예를 들어, N번째 피보나치 수를 구한다. D[N] 은 N번째 피보나치 수다.
  - 문제를 작은 문제로 만든다.
   + D[N-1], D[N-2]
  - 작은 문제로 어떻게 원래 문제를 풀 수 있을지 생각한다.
   + D[N] = D[N-1] + D[N-2]

 ## 문제풀이
  - 1,2,3 더하기 5(BOJ 15990)
   + 같은 수를 두 번 이상 연속해서 사용할 수 없다.
   + 점화식을 사용하기 위해 마지막에 사용한 수를 알아야 한다. 
   + dp[i][j] = i를 1,2,3으로 나타낼 때, j가 마지막 수인 경우의 수
  - 가장 긴 증가하는 부분수열 4(BOJ 14002)
   + 실제 LIS를 출력해야 하는 문제
   + 값이 바뀔 때마다 인덱스를 기록해놓는다. 
   + 실제 LIS를 복원하는 과정이 필요하다.
  - 연속합(BOJ 1912)
   + 문제 값의 범위를 잘 생각하고 답을 구해야한다..;
  - 합분해(BOJ 2225)
   + 1,2,3 더하기 변형문제
   + 점화식을 잘 생각해봐야한다.
 
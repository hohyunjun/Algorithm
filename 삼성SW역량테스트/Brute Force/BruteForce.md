# Brute Force

 ## Brute Force란?
 - 모든 경우의 수를 다 해보는 것이다. 
 - 예를 들어, 비밀번호가 4자리이고, 숫자로만 이루어져 있다고 한다면 0~9999까지 모든 경우의 수를 다 해보는 것이다.
 - 일반적으로, 문제의 가능한 경우의 수가 백만~천만인 경우에 브루트 포스를 통한 구현이 가능하다. 
 - 브루트 포스로 문제를 풀기 위해서는 다음과 같은 3가지 단계를 생각해 볼 수 있다.
  + 문제의 가능한 경우의 수를 계산해본다.
   - 직접 계산을 통해서 구한다. 대부분 손으로 계산해 볼 수 있다.
  + 가능한 모든 방법을 다 만들어 본다.
   - 하나도 빠짐없이 만들어야 한다.
   - 대표적으로 그냥 다 해보는 방법, for문 사용, 순열 사용, 재귀 호출 사용, 비트마스크 사용이 있다.
  + 각각의 방법을 이용해 답을 구해본다.
 - 브루트 포스 문제의 시간 복잡도는 대부분 O(경우의 수 * 방법 1개를 시도해 보는데 걸리는 시간복잡도) 가 걸린다. 

 ## 그냥 다 해보기
 - 일곱 난쟁이(BOJ 2309)
  + 그냥 다 해본다. 9명 중에서 2명을 고른다. 

 ## N중 for문
 - N개 중에 일부를 선택해야 하는 경우에 많이 사용한다.
 - 재귀 호출이나 비트마스크를 사용하면 더 간결하고 보기 쉬운 코드를 작성할 수 있기 때문에, 사용할 일이 거의 없다. 

 ## 순열 사용하기
 - 1~N까지로 이루어진 수열
 - 크기가 N인 순열은 총 N!개가 존재한다.
 - 순열을 사전순으로 정렬할 때, 첫 순열은 무조건 오름차순, 마지막 순열은 무조건 내림차순.
 - 다음 순열
  + 순열을 사전순으로 나열했을 때, 사전순으로 다음에 오는 순열과 이전에 오는 순열을 찾는 방법
  + C++ STL의 algorithm에는 이미 next_permutation과 prev_permutation이 존재하기 때문에 사용하면 된다. 
 - 다음 순열을 구하는 방법
  + 1. A[i-1] < A[i] 를 만족하는 가장 큰 i를 찾는다.
  + 2. j>=i 이면서 A[j] > A[i-1] 을 만족하는 가장 큰 j를 찾는다.
  + 3. A[i-1]과 A[j]를 swap한다.
  + 4. A[i]부터 순열을 뒤집는다. 
  + 시간복잡도 계산 : i-1을 찾는 과정 O(N), j를 찾는 과정 O(N), swap O(1), 순열 뒤집기 O(N).
  + 각각의 과정들이 다 독립된 과정이므로, O(3N+1) = O(N)이다.

 ## 순열 사용문제
 - 순열을 사용해서 문제를 풀 경우, 시간복잡도는 일반적으로 O(N * N!) 이다. N의 최댓값은 10이라고 보면 된다.
 - 외판원 순회2(BOJ 10971)
  + N이 10 이하이므로 충분히 모두 다 해 볼 수 있다.
  + 모든 순열에 대해 다 수행해 봐도 되지만, 더 좋은 방법이 있다.
  + 1 2 3 4 / 2 3 4 1 / 3 4 1 2 / 4 1 2 3 은 모두 같은 경우이므로, 시작점을 1로 고정해도 된다. 
  + 즉, next_permutation을 begin()+1 부터 수행해주면, 시간복잡도는 O(N!) 이 된다. 
  + 외판원 순회는 매우 중요한 문제!!
 - 로또(BOJ 6603)
  + 입력으로 주어진 K개의 수에서 6개의 수를 고르는 문제
  + 1이 6개, 0이 K-6개 들어간 순열을 만들고 모든 순열을 만들어보면서 답을 구할 수 있다. 
  + 즉, permutation을 이용해서 combination을 만들 수 있다!!
  + 일반적으로, 순열을 이용해서 풀 수 있는 고르는 문제는 고르는 개수가 고정되어 있다.
 - 연산자 끼워넣기(BOJ 14888)
  + 각 연산자의 개수별로 숫자를 넣은 순열을 만들고 그것을 이용해서 문제를 풀 수 있다.

 ## 재귀함수 사용하기
 - 문제를 통해 어떻게 재귀함수를 사용할 수 있는지 알아본다.
 - 1,2,3 더하기(BOJ 9095)
  + 재귀함수를 통해 모든 방법을 만들어본다.
  + go(count, sum, goal)
   - 가능한 경우의 수 : 불가능한 경우, 정답을 찾은 경우, 다음 경우를 호출하는 경우
   - 불가능한 경우 : 합이 goal보다 커지는 경우(sum > goal)
   - 정답을 찾은 경우 : 합이 goal과 같은 경우
   - 다음 경우를 호출하는 경우 : 1을 사용하는 경우(go(count+1, sum+1, goal)), 2를 사용하는 경우(go(count+1, sum+2, goal)),
                               3을 사용하는 경우(go(count+1, sum+3, goal))
   - 코드의 시간 복잡도는 O(3^n) 이다. 함수 하나당 함수를 3번 호출하므로.
 - 암호 만들기(BOJ 1759)
  + 재귀함수를 통해 모든 방법을 만들어본다.
  + 가능성 있는 암호를 모두 구하는 문제. 실제로 모든 경우의 수를 다 구해야 한다. Brute Force
  + 조건들을 살펴보자.
   - 암호를 이루는 알파벳이 암호에서 증가하는 순서로 배열되어 있어야 한다
      -> 사용되는 알파벳을 증가하는 순서로 만들어 놓은 다음에 거기에서 적절히 순서를 유지하면서 암호를 빼낸다. 
   - 암호를 만들기 위해 알파벳을 사용하는 경우와 사용하지 않는 경우 둘로 나누어 생각해 볼 수 있다. 
   - 문제의 조건에서 총 C가지 중에서 L개를 고르는 것이고, C의 최대값은 15이므로 만들 수 있는 최대 가짓수는 2^15를 넘지 않는다. 
   - 따라서, 2^15를 넘지 않는 모든 암호를 만든 다음에, 그것이 한개의 모음과 두 개의 자음 이상으로 구성되어 있는지를 따지는 것이다. 
  + go(n, alpha, password, i)
   - n : 만들어야 하는 암호의 길이
   - alpha : 사용가능한 알파벳
   - password : 현재까지 만든 암호
   - i : 사용할지 말지 결정해야 하는 알파벳의 인덱스 
   - 불가능한 경우 : n < password.length() 인 경우, i가 alpha의 인덱스보다 커질 경우
   - 정답을 찾은 경우 : n == password.length() 이고, 한 개 이상의 모음과 두 개 이상의 자음으로 구성되어 있는 경우
   - 다음 경우를 호출하는 경우 : i번째 인덱스를 사용하는 경우, go(n, alpha, password + alpha[i], i+1);
                               i번째 인덱스를 사용하지 않는 경우, go(n, alpha, password, i+1);
   **정답을 찾은 경우와 불가능한 경우의 순서에 따라 결과값이 다르게 나옴에 주의한다**
  + 불가능한 경우와 정답을 찾은 경우의 순서?
   - 앞서 1,2,3 더하기 문제에서는 정답을 찾은 것과 불가능한 것의 순서를 바꿔도 된다. 두 개를 동시에 만족하는 경우가 없기 때문
   - 암호 만들기의 경우 두 개를 동시에 만족하는 경우가 발생하게 된다. alpha의 마지막 char가 password의 마지막이 될 경우. 
     즉, 더 이상 선택할 수 없는 알파벳이 없는데 암호의 개수가 n과 같은 경우가 발생한다.
     따라서 먼저 정답을 찾은 경우를 호출해 주어야 한다. 
 - 로또(BOJ 6603)
  + 암호 만들기와 비슷한 문제.
 - 부분집합의 합(BOJ 1182)
  + 앞의 문제들과는 약간 다름. 정답을 찾았을 경우의 수를 잘 생각해 주어야 한다.
  + 합이 같으면 끝나는 것이 아니라, 모든 부분집합을 찾아야 하므로 더 진행해 주어야 한다.
  + **합이 같은 걸 찾았다는 것이 다음 경우를 호출할 필요가 없음을 의미하는 것이 아니다!!**
 - 퇴사(BOJ 14501)
  + 계속 고민해봤는데 결국 못풀어서 해설 본 문제. 다시 한 번 꼭 풀어봐야 할 문제.
  + 변수의 의미를 고려해서 변수명을 정해주자. 변수의 의미를 먼저 명확하게 해야 한다. 
  + 불가능한 경우 : 문제의 조건을 위배하는 경우(day > n)
  + 정답을 찾은 경우 : day == n. 퇴사일이 되는 순간 상담을 할지 말지 결정할 필요 없이 퇴사하면 된다. 
  + 다음 경우를 호출하는 경우 : 상담을 한다(go(day+t[day], sum+p[day])), 상담을 하지 않는다(go(day+1, sum))
  + **재귀함수를 통해 최대 / 최소값을 구하는 유형의 Brute Force 문제**
 - 연산자 끼워넣기(BOJ 14888)
  + 끼워넣는 경우의 수 4가지를 모두 다 재귀함수를 통해 구현해본다.

 ## 비트마스크 사용하기
 - 비트마스크를 이용해서 모든 경우의 수를 만든다.
 - 비트마스크란?
  + 비트연산을 이용해서 모든 부분집합을 표현하는 것을 의미한다. 
  + 비트연산에는 총 4가지가 있다. &(and), |(or), ~(not), ^(xor)
  + 두 수 A와 B를 비트연산 하는 경우에는 가장 뒤의 자리부터 하나씩 연산을 수행하면 된다. 
  + not 연산의 경우에는 자료형에 따라 결과가 달라진다. 
   - 자료형에 따라 전체 비트의 개수가 달라지기 때문이다.
   - 또, unsigned, signed 에 따라서 보여지는 값은 다르다. 
  + shift left(<<) 와 shift right(>>) 연산이 있다.
   - A << B 는 A * 2^B와 같다.
   - A >> B 는 A / 2^B와 같다. 
   - (A+B)/2 는 (A+B) >> 1로 쓸 수 있다. 
  + 정수로 집합을 나타낼 수 있다. 
   - {1,3,4,5,9} = 570 = 2의 1승 + 2의 3승 + 2의 4승 + 2의 5승 + 2의 9승
   - 하지만 굳이 비트마스크를 써서 집합을 정수로 나타내는 이유가 있을까?
   - 있다. 일단 공간적인 측면에서 정수 하나와 정수 열개를 배열로 저장하는 것은 어마어마한 차이가 있다. 
   - 또한, 배열을 다른 배열의 key 값으로 사용하는 등의 활용이 가능하다. ex) a[c] (c 는 배열, 불가능), a[570] 가능. 
   - 보통 0~n-1까지 정수로 이루어진 집합을 나타낼 때 사용한다. 
 - 비트마스크 연산
  + {1,3,4,5,9} = 570
  + 비트마스크에서 어떤 수가 포함되어 있으면 1이 들어있고, 포함되어 있지 않으면 0이 들어있다. 
  1. 특정 숫자가 포함되어 있는지를 & 연산을 통해 확인할 수 있다. 
   + S를 비트마스크라고 할 때, *S & (1 << i)* 의 결과가 0 이면, i가 없는 것이고, 결과가 0이 아니면, i가 있는 것이다. 
  2. 비트마스크에 새로운 수를 추가하는 연산
   + 추가한다면 0을 1로 만들어주면 된다. 따라서 |(or) 연산을 이용한다.  
   + *S | (1 << i)*
  3. 비트마스크에 새로운 수를 제거하는 연산
   + 제거한다면 1을 0으로 만들어주면 된다. 따라서 1과 0을 &(and) 연산해 주는 방법을 사용가능하다. 
   + 지우려고 하는 수만 0으로 만들고, 나머지는 다 1로 만들어야 한다. 
   + *S & ~(1 << i)* 형태로 구현 가능하다. 
  4. toggle 연산
   + 1을 0으로, 0을 1로 만드는 연산. ^(xor) 연산을 통해 해결 가능하다. 
   + *S ^ (1 << i)*
  5. 전체 집합과 공집합 만들기
   + 전체집합은 모두를 포함하므로 전체가 다 1, 공집합은 전체가 다 0
   + 전체집합은 (1 << N) -1, 공집합은 0
 - C++ 의 bitset
  + C++ 기준으로 int 는 32비트, long long 은 64 비트이다. 
  + 64비트를 넘는 비트는 정수로 나타낼 수 없다. 
  + 이런 경우에는 C++의 bitset을 이용하면 된다. 하지만 쓸일없음. 참고용으로만 알아두세영. 

 ## N과 M
 - 재귀함수 연습하기 좋은 문제들 12문제
 - 기본문제는 N과M 1~4
 - 5~12는 1,2,3,4 를 변형해서 만든 문제들 
 - N과 M(1) (BOJ 15649)
  + 간단해 보이는 문제인데 생각하기 너무 어려웠다.. 재귀함수 너무 어려운 것 같다
  + check 배열을 통해 중복을 방지하고, for문을 돌린다.
 - N과 M(2) (BOJ 15650)
  + 처음에는 N과 M 1번에서 오름차순일 경우만 출력하도록 조건문을 바꿔주는 식으로 풀었다.
  + 어차피 오름차순이므로, 해당 인덱스를 선택하거나 선택하지 않거나 하는 식으로 재귀함수를 세울 수 도 있겠다는 생각이 들었다.
   - 그런데, 재귀함수에서 int 배열을 어떤 식으로 넘겨줘야 하는지 모르겠다..
   - **재귀함수에서 int 배열을 바꾸는 방식에 대해서 체크해야한다**
 - N과 M(3) (BOJ 15651)
  + N과 M(1)의 변형문제
  + 하.. 왜 잘 모르겠지;;
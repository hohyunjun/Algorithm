## 수학 기초 공식들
  - 나머지 연산
   + (A+B)%C = ((A%C) + (B%C))%C
   + (A*B)%C = ((A%C) * (B%C))%C  

  - 최대공약수
   + A,B 의 공통된 약수 중에서 가장 큰 정수
   + 최대공약수가 1인 두 수를 서로소(Coprime)이라고 한다.
   + 2부터 min(A,B) 까지 모든 정수로 나누어 보는 방법을 사용한다.
   + 최대공약수를 찾는 가장 빠른 방법은 유클리드 호제법
   + GCD(a,b) = GCD(b,r)
   + r=0 이 되면 그 때의 b 값이 최대 공약수이다.  
   + 3개 이상의 숫자에 대한 최대공약수는 다음과 같이 구할 수 있다.
   + GCD(a,b,c) = GCD(GCD(a,b),c);

  - 최소공배수
   + 두 수 a,b의 최대공약수를 g라고 했을 때,
   + 최소공배수 l = g*(a/g)*(b/g) 이다.
   + 두 수 a * b = g * l 이다.
   + 두 자연수의 곱 = 최대공약수 * 최소공배수

  - 진법 변환
   + 10진법 수 N을 B진법으로 바꾸려면 N이 0이 될때까지의 나머지를 계속해서 구하면 된다. 
   + 구한 나머지를 역순으로 나열하면 된다. --> 스택에 넣어서 pop하면 간편
   + B진법 수 N을 10진수로 바꾸려면 B^k을 곱하면서 더해가면 된다.
   + A진법을 B진법으로 바꾸려면 A진법 -> 10진법 -> B진법의 과정을 거치면 된다.

  - 소수
   + 약수가 1과 자기 자신밖에 없는 수
   + N이 소수가 되려면, 2보다 크거나 같고, N-1보다 작거나 같은 자연수로 나누어 떨어지면 안된다.
   + ---> N의 약수 중에서 가장 큰 것은 N/2보다 작거나 같기 때문에,
   +      N이 소수가 되려면, 2보다 크거나 같고, N/2보다 작거나 같은 자연수로 나누어 떨어지면 안된다. ( O(N) )
   + **어떤 수가 소수인지 아닌지를 판별하는 가장 빠른 방법**
   + N이 소수가 되려면, 2보다 크거나 같고, 루트 N보다 작거나 같은 자연수로 나누어 떨어지면 안된다. ( O(rootN) )
   + 위 식을 활용해서 1~N까지의 소수의 개수를 구하는 것의 시간복잡도는 O(NrootN)
   ```
   bool isPrime(int n){
      if(n<2){
          return false;
      }
      for(int i=2; i*i<=n; i++){
          if(n%i==0) return false;
      }

      return true;
    }
   ```
   + 이보다 더 빠른 방식이 있다.
   + **에라토스테네스의 체**
   + 1~N 까지 범위 안에 들어가는 모든 소수를 구하려면 에라토스테네스의 체를 사용한다. 
    - 2부터 N까지 모든 수를 써놓는다.
    - 아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다.
    - 그 수는 소수이다.
    - 이제 그 수의 배수를 모두 지운다.
    - *어떤 수를 기준으로 해서 그 수의 제곱보다 작은 수는 이미 지워져 있다.*
    - *즉, 반복문을 돌릴때, 제곱수부터 시작해서 지우면 된다.*
    - *제곱했을 때 값의 범위가 Overflow가 나는지 여부에 주의한다.*
   + 에라토스테네스의 체는 거의 시간복잡도가 거의 Linear하다고 생각하면 된다.
   ```
    for(int i=2; i*i<=1000000; i++){
      if(check[i]==false){
          for(int j=i*2; j<=1000000; j+=i){
              check[j] = true;
          }
      }
    }
   ```
  
  - 골드바흐의 추측
   + 2보다 큰 모든 짝수는 두 소수의 합으로 표현 가능하다.
   + 위의 문장에 3을 더하면
   + 5보다 큰 모든 홀수는 세 소수의 합으로 표현 가능하다.
   + 아직 증명되지 않았지만, pow(10,18) 이하에서는 참인 것이 증명되었다.
  
  - 소인수분해
   + 정수 N을 소수의 곱으로 분해
   + 소수를 구하지 않고도 해결할 수 있다.
   + N을 소인수분해 했을 때, 나타날 수 있는 인수 중에서 가장 큰값은 루트 N이다.
   + 따라서 2부터 루트 N까지 for문을 돌면서
   + N을 나눌 수 있으면, 나눌 수 없을 때까지 계속해서 나누면 된다.
   ```
    for(int i=2; i*i<=N; i++){
      while(N%i==0){
          cout << i << '\n';
          N/=i;
      }
    }

    if(N!=1){
        cout << N << '\n';
    }
   ```



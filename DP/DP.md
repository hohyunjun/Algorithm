## DP 기초
  큰 문제를 작은 문제로 나눠서 푸는 알고리즘  
  Dynamic Programming의 다이나믹은 아무 의미가 없다.  
  처음 사용한 Richard Bellman은 멋있어보여서 사용했다고 한다.  
  - 두 가지 속성을 만족해야 다이나믹 프로그래밍으로 문제를 풀 수 있다.  
    1. Overlapping Subproblem 겹치는 부분문제  
    2. Optimal Substructure 문제의 정답을 작은 문제의 정답에서 구할 수 있다.  

  - 다이나믹 프로그래밍에서 각 문제는 한 번만 풀어야 한다.
  - Optimal Substructure를 만족하기 때문에, 같은 문제는 구할 때마다 정답이 같다.
  - 따라서, 정답을 한 번 구했으면, 정답을 어딘가에 메모해 놓는다.(Memoization)
  - 이런 메모하는 것을 코드의 구현에서는 배열에 저장하는 것으로 할 수 있다.

## DP 문제를 푸는 두 가지 방법
  구현을 어떻게 하는가의 차이!!
  1. Top-down
    - 문제를 작은 문제로 나눈다.
        fibonacci(n) = fibonacci(n-1) + fibonacci(n-2);
    - 작은 문제를 푼다.
        fibonacci(n-1) 과 fibonacci(n-2)를 호출해 문제를 푼다.
    - 작은 문제를 풀었으니, 문제를 푼다.
        fibonacci(n-1)과 fibonacci(n-2)를 더해 값을 구한다.
    **시간복잡도 계산**
    **채워야 하는 칸의 수x1칸을 채우는 복잡도**
    ex) 피보나치는 N x O(1) 이므로, O(N)
  2. Bottom-up
    - 문제를 크기가 작은 문제부터 차례대로 푼다.
    - 문제의 크기를 조금씩 크게 만들면서 문제를 점점 푼다.
    - 작은 문제를 풀면서 왔기 때문에, 큰 문제는 항상 풀 수 있다.
    - 그러다보면, 언젠가 풀어야 하는 문제를 풀 수 있다.
    ```
    int d[100];
    int fibonacci(int n){
        d[0] = 0;
        d[1] = 1;
        for(int i=2; i<=n; i++){
            d[i] = d[i-1] + d[i-2];
        }
        return d[n];
    }
    ```
## 문제 풀이 전략
  1. 문제에서 구하려고 하는 답을 문장으로 나타낸다.
  2. 문장에 나와있는 변수의 개수만큼 메모하는 배열을 만든다.
    - Top-down인 경우에는 재귀 호출 인자의 개수
  3. dp[i] 에 무엇이 들어가야 하는지부터 정의한다.
  4. 문제를 작은 문제로 나누고, 점화식을 세운다. 

## DP 활용
  - 피보나치 수  
    문제를 작은 문제들로 나누어서 푸는 것이 핵심인데, 이 때 작은 문제들이 겹쳐야 함.  
    Fn = Fn-1 + Fn-2 (n>=2)
    
    Overlapping Subproblem : 문제는 Fn, 작은 문제는 Fn-1, Fn-2를 구하는 것
    서로를 구하는 과정이 Overlapping 된다.
    문제의 크고 작음은 상대적이다.

    즉, Overlapping Subproblem 이란,
    **큰 문제와 작은 문제를 같은 방법으로 풀 수 있다.**
    **문제를 작은 문제로 쪼갤 수 있다.**

    Optimal Substructure
    - 문제의 정답을 작은 문제의 정답에서 구할 수 있다.

    ```
    서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 순서대로 거쳐야 한다면
    대전에서 부산을 가는 가장 빠른 길은 대구를 거쳐야 한다.

    피보나치 수에서,
    문제의 정답을 작은 문제의 정답을 합하는 것으로 구할 수 있다.
    ```
    - Optimal Substructure를 만족한다면, 문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다. 
     예를 들어, 4번째 피보나치 수 F4의 값은 항상 동일하다.
     이것을 이용하는 것이 다이나믹 프로그래밍이다.  

    - 피보나치 수 예제
    ```
    // 한 번 답을 구할 때, 어딘가에 메모를 해 놓고, 중복호출이면 메모해놓은 값을 리턴한다. 
    // memo[n] = n번째 피보나치수
    int memo[100]= {};
    int fibonacci(int n){
        if(n<=1){
            return n;
        }else{
            if(memo[n]>0){
                return memo[n];
            }
            memo[n] = fibonacci(n-1) + fibonacci(n-2);
            return memo[n];
        }
    }
    ```


